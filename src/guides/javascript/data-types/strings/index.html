<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../../../../public/css/docs.css">
  <link rel="stylesheet" href="../../../../public/css/themes/overlook.css">
  <style>
    table code {
      background-color: #f7df1e !important;
    }
  </style>
  <title>Data type - String</title>
</head>

<body>
  <article class="markdown-body">
    <h1 align="left">
      <img
        src="https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E"
        height="50" align="left">
      <img src="https://raw.githubusercontent.com/EniDev911/assets/main/png/logo/logo_sin_bg.png" height="55"
        align="right"><br><br>
      <code>DATA TYPES: STRING</code>
    </h1>

    <h2 id="contenido">CONTENIDO<a class="headerlink" href="#contenido" title="Permanent link">&#9875;</a></h2>
    <p><a name="top"></a></p>
    <ul>
      <li><a href="#what-is">¿Qué es un String?</a></li>
      <li><a href="#string-property">Propiedades</a></li>
      <li><a href="#string-positional-method">Métodos de posiciones</a></li>
      <li><a href="#string-search-method">Métodos para búsquedas</a></li>
      <li><a href="#string-transform-methods">Métodos para transformar</a></li>
      <li><a href="#string-replace">Remplazar texto</a></li>
      <li><a href="#string-extract">Extraer subtextos</a></li>
      <li><a href="#string-split">Crear arrays a partir de textos</a></li>
      <li><a href="#fill-string">Rellenar string</a></li>
      <li><a href="#string-unicode">Métodos unicode</a></li>
      <li><a href="#string-backstips">Interpolación de variables</a></li>
    </ul>
    <hr>
    <h3 id="que-es-un-string"><a name="what-is"></a> ¿Qué es un String?<a class="headerlink" href="#que-es-un-string"
        title="Permanent link">&#9875;</a></h3>
    <p>En javascript y en cualquier otro lenguaje de programación, una de las tareas que más se suelen hacer es manejar
      cadenas de textos y realizar tareas con ellas. Por lo tanto, es importante ver en profundidad sus características
      así como sus atributos y funciones de este tipo de dato. </p>
    <p>Un <strong><a href="https://en.wikipedia.org/wiki/String_(computer_science)" target="_blank">string</a></strong>
      en
      javascript se utiliza para representar un conjunto de caracteres usado para representar el texto. En programación,
      cuando hablamos de una variable que posee información de texto, decimos que su tipo de dato es un
      <code class="str">String</code>. En Javascript, es muy sencillo crear una variable de texto, hay dos formas:
    </p>

    <table>
      <thead>
        <tr>
          <th>Constructor</th>
          <th>Descripción</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong><code>new String(s)</code></strong></td>
          <td>Crea un objeto de texto a partir del texto <strong>s</strong>.</td>
        </tr>
        <tr>
          <td><strong><code>'s'</code></strong></td>
          <td>Solo colocando el texto entre comillas (forma más común).</td>
        </tr>
      </tbody>
    </table>

    <p>Los <strong><code class="str">string</code></strong> son tipos de datos primitivos, y como tal, es más sencillo
      utilizar los
      literales que la notación con <code class="new">new</code>. Para englobar los textos, se pueden utilizar
      <strong>comillas
        simples</strong> <code>'</code>, <strong>comillas dobles</strong> <code>"</code> o <strong>backstiks</strong>
      <code>`</code> (estos últimos tienen uso más extendido que veremos más adelante).
    </p>
    <blockquote>
      <p>Aunque es posible utilizar comillas simples o comillas dobles en los string, es recomendable decantarse por uno
        de los dos estilos y no mezclarlos. </p>
    </blockquote>
    <p>A continuación, un ejemplo de declaración de variables de texto en JavaScript: </p>
    <div class="highlight">
      <pre><span class="c1">// Literales</span>
<span class="kr">const</span> <span class="nx">textoPrincipal</span> <span class="o">=</span> <span class="s2">&quot;¡Hola Javascript!&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">textoSecundario</span> <span class="o">=</span> <span class="s2">&quot;Otro mensaje de texto&quot;</span><span class="p">;</span>

<span class="c1">// Objeto</span>
<span class="kr">const</span> <span class="nx">textoPrincipal</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">String</span><span class="p">(</span><span class="s2">&quot;¡Hola Javascript!&quot;</span><span class="p">)</span>
<span class="kr">const</span> <span class="nx">textoSecundario</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">String</span><span class="p">(</span><span class="s2">&quot;Otro mensaje de texto&quot;</span><span class="p">)</span>
</pre>
    </div>

    <p>A diferencia de otros lenguajes de programación, que separan el tipo de dato <code class="str">string</code> del
      tipo de dato
      <code>char</code> (un solo carácter), javascript los mantiene a ambos dentro del tipo de dato <code
        class="str">string</code>,
      aunque una variable sólo contenga un carácter, sigue siendo un <code class="str">string</code>.
    </p>
    <p><a href="#top"><img alt=""
          src="https://img.shields.io/badge/regresar%20a%20contenido%20principal-%E2%86%A9-%232BAAEC?style=for-the-badge&amp;logo=readthedocs&amp;logoColor=%23FAC173" /></a>
    </p>
    <hr />
    <h3 id="propiedades"><a name="string-property"></a> PROPIEDADES<a class="headerlink" href="#propiedades"
        title="Permanent link">&#9875;</a></h3>
    <p>Al crear una variable con contenido de texto, o sea un <code class="str">string</code>, automáticamente, esa
      variable pasa a
      tener a su disposición todas las propiedades y métodos disponibles para este tipo de dato, por lo que podemos
      utilizarlo en nuestro código como iremos viendo a continuación.</p>
    <table>
      <thead>
        <tr>
          <th>Propiedad</th>
          <th>Descripción</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>.length</code></td>
          <td>Devuelve un (<strong>number</strong>) que es el número de carácteres de la variable de tipo string.</td>
        </tr>
      </tbody>
    </table>
    <p>En el caso de los string, solo tenemos una propiedad, <strong><code>.length</code></strong>, que devuelve el
      tamaño de la variable de texto. A continuación podemos observar que se han utilizado <code
        class="str">string</code>
      directamente, sin necesidad de guardarlos en una variable antes: </p>
    <div class="highlight">
      <pre><span class="s2">&quot;Javascript&quot;</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="c1">// 10</span>
<span class="s2">&quot;Mi nombre es marco&quot;</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="c1">// 18 (los espacios en blanco cuentan)</span>
<span class="s2">&quot;&quot;</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="c1">// 0</span>
</pre>
    </div>

    <p>Pero las características más interesantes de los string se encuentran en los métodos de dicho tipo. Se debe tener
      en cuenta que, en las variables de texto, los métodos se ejecutan sobre el propio texto del
      <strong><code class="str">string</code></strong>, devolviendo información modificada a partir de este.
    </p>
    <p><a href="#top"><img alt=""
          src="https://img.shields.io/badge/regresar%20a%20contenido%20principal-%E2%86%A9-%232BAAEC?style=for-the-badge&amp;logo=readthedocs&amp;logoColor=%23FAC173" /></a>
    </p>
    <hr />
    <h3 id="metodos-de-posiciones"><a name="string-positional-method"></a> MÉTODOS DE POSICIONES<a class="headerlink"
        href="#metodos-de-posiciones" title="Permanent link">&#9875;</a></h3>
    <p>En primer lugar existen varios métodos que permiten darnos información sobre la <strong>posición</strong> o
      <strong>ubicación</strong> que ocupa un determinado carácter o texto. Esta posición también suele denominarse
      <strong>índice</strong>. Veamos detalladamente dichos métodos:
    </p>
    <table>
      <thead>
        <tr>
          <th>Método</th>
          <th>Descripción</th>
          <th>Op.</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong><code>.charAt(pos)</code></strong></td>
          <td>Devuelve el carácter en la posición <strong>pos</strong> de la variable.</td>
          <td><code>[]</code></td>
        </tr>
        <tr>
          <td><strong><code>.concat(str1, str2...)</code></strong></td>
          <td>Devuelve el texto de la variable unido a <strong>str1</strong>, a <strong>str2</strong>&hellip;</td>
          <td><code>+</code></td>
        </tr>
        <tr>
          <td><strong><code>.indexOf(str)</code></strong></td>
          <td>Devuelve la primera posición del texto <strong>str</strong>.</td>
          <td></td>
        </tr>
        <tr>
          <td><strong><code>.indexOf(str, from)</code></strong></td>
          <td>Igual al anterior, partiendo desde la posición <strong>from</strong>.</td>
          <td></td>
        </tr>
        <tr>
          <td><strong><code>.lastIndexOf(str,from)</code></strong></td>
          <td>identico al anterior, pero devuelve la última posición.</td>
          <td></td>
        </tr>
      </tbody>
    </table>
    <p>El método <strong><code>.charAt(pos)</code></strong> nos permite comprobar que carácter se encuentra en la
      posición <strong>pos</strong> del texto. Este método devolverá un <code class="str">string</code> con dicho
      carácter. En caso
      de pasarle una posición que no existe, simplemente nos devolverá un <strong>string vacio</strong> <code>""</code>.
      El valor por defecto de <strong>pos</strong> es 0.</p>
    <div class="highlight">
      <pre><span class="s2">&#39;marco&#39;</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// devuelve &quot;a&quot;</span>
</pre>
    </div>

    <p>La otra forma (introducida en ECMAScript 5) es tratar a la cadena como un objeto similar a un arreglo, donde los
      caracteres individuales corresponden a un índice numérico: </p>
    <div class="highlight">
      <pre><span class="s2">&#39;marco&#39;</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// devuelve a &quot;a&quot;</span>
</pre>
    </div>

    <p>No obstante, es preferible utilizar el operador <code>[]</code> para obtener el carácter que ocupa una posición,
      ya que es más corto y rápido de utilizar y mucho más claro. La diferencia respecto a
      <strong><code>charAt()</code></strong> es que el operador <code>[]</code> devuelve <a
        href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/undefined"><strong><code>undefined</code></strong></a>
      si en esa posición no existe ningún carácter.
    </p>
    <p>El método <strong><code>.concat(str1, str2...)</code></strong> permite concatenar (unir) los
      textos pasados por parámetros al de la propia variable. AL igual que
      el método anterior es preferible utilizar el operador <code>+</code>, ya que es
      mucho más rápido y legible. Debemos tener mucho cuidado con utilizar el operador <code>+</code>, ya que depende de
      los tipos de datos con los que se usen puede producir un efecto diferente. El operador <code>+</code> usado con
      <code class="str">string</code> realiza concatenaciones, mientras que usado con <a
        href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Number"><code>number</code></a>
      realiza sumas.
    </p>
    <p>
    <div class="highlight">
      <pre><span class="s2">&quot;enidev&quot;</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// enidev911</span>
<span class="s2">&quot;enidev&quot;</span><span class="o">+</span><span class="mi">9</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span> <span class="c1">//enidev911</span>
<span class="mi">9</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span> <span class="c1">// 11</span>
</pre>
    </div>
    <details>
      <summary>clic demo</summary>
      <p align="center">
        <img src="assets/concat.gif" />
      </p> <br />
    </details>
    </p>
    <p>Por último, nos queda el método <strong><code>indexOf(str, from)</code></strong>, que es la función opuesta
      <strong><code>charAt()</code></strong>. La función <strong><code>indexOf(str)</code></strong> buscará el subtexto
      <strong>str</strong> en nuestra variable y nos devolverá un <code>number</code> con la <strong>posición</strong>
      de la primera aparición de dicho subtexto. En caso de no encontrarlo, devolvera <strong>-1</strong>. El parámetro
      <strong>from</strong> es opcional, y es la posición en la que empezará a buscar, que por defecto (si no se
      suministra) es <strong>0</strong>.
    </p>
    <div class="highlight">
      <pre><span class="s2">&quot;Javascript, es muy amigable&quot;</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">);</span> <span class="c1">// 1</span>
<span class="s2">&quot;Javascript, es muy amigable&quot;</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// 3</span>
<span class="s2">&quot;Javascript, es muy amigable&quot;</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// 19</span>
</pre>
    </div>

    <details>
      <summary>clic demo</summary>
      <p align="center">
        <img src="assets/indexOf.gif" />
      </p>
    </details>

    <p>El método <strong><code>lastIndexOf(str, from)</code></strong> funciona exactamente igual que el anterior, sólo
      que realiza la búsqueda de la <strong>última aparición</strong> en lugar de la primera aparición.</p>
    <p><a href="#top"><img alt=""
          src="https://img.shields.io/badge/regresar%20a%20contenido%20principal-%E2%86%A9-%232BAAEC?style=for-the-badge&amp;logo=readthedocs&amp;logoColor=%23FAC173" /></a>
    </p>
    <hr />
    <h3 id="metodos-para-busquedas"><a name="string-search-method"></a> MÉTODOS PARA BÚSQUEDAS<a class="headerlink"
        href="#metodos-para-busquedas" title="Permanent link">&#9875;</a></h3>
    <p>Los siguientes métodos se utilizan para realizar búsquedas o comprobaciones de subtextos en el texto de un
      <code class="str">string</code>.
    </p>
    <table>
      <thead>
        <tr>
          <th>Método</th>
          <th>Descripción</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong><code>.startsWith(s,from)</code></strong></td>
          <td>Comprueba si el texto comienza por <strong>s</strong> desde la posición <strong>from</strong>.</td>
        </tr>
        <tr>
          <td><strong><code>.endsWith(s,to)</code></strong></td>
          <td>Comprueba si el texto hasta la posición <strong>to</strong>, termina pos <strong>s</strong>.</td>
        </tr>
        <tr>
          <td><strong><code>.includes(s,from)</code></strong></td>
          <td>Comprueba si el texto contiene el subtexto <strong>s</strong> desde la posición <strong>from</strong>.
          </td>
        </tr>
        <tr>
          <td><strong><code>.search(regex)</code></strong></td>
          <td>Busca si hay un patrón que encaje con <strong>regex</strong> (<em>expresión regular</em>) y devuelve la
            posición.</td>
        </tr>
        <tr>
          <td><strong><code>.match(regex)</code></strong></td>
          <td>Identico al anterior, pero devuelve las coincidencias encontradas.</td>
        </tr>
        <tr>
          <td><strong><code>.matchAll(regex)</code></strong></td>
          <td>Identico al anterior, pero devuelve un iterador para iterar por cada coincidencia.</td>
        </tr>
      </tbody>
    </table>
    <p>Por ejemplo, el método <code>startsWith(str, from)</code> devolverá <code>true</code> si la variable comienza por
      el texto proporcionado en <strong>str</strong>. Si además se indica el parámetro opcional <strong>from</strong>,
      empezará en la posición <strong>from</strong> del <code class="str">string</code>. De la misma forma, el método
      <strong><code>endsWith()</code></strong> comprueba cuando un <code class="str">string</code> acaba en
      <strong>str</strong>, y
      el método <strong><code>includes()</code></strong> comprueba si el subtexto dado está incluído en el
      <code class="str">string</code>.
    </p>
    <p>Algunos ejemplos:</p>
    <div class="highlight">
      <pre><span class="s2">&quot;Enidev911&quot;</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">);</span> <span class="c1">// true (&#39;Enidev911&#39; comienza con E)</span>
<span class="s2">&quot;Enidev911&quot;</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// true (&#39;ev911&#39;, comienza con e)</span>
<span class="s2">&quot;Enidev911&quot;</span><span class="p">.</span><span class="nx">endsWidth</span><span class="p">(</span><span class="s2">&quot;o&quot;</span><span class="p">);</span> <span class="c1">// false (&#39;enidev911&#39;, no termina con &#39;o&#39;)</span>
<span class="s2">&quot;Enidev911&quot;</span><span class="p">.</span><span class="nx">endsWidth</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// true (&#39;Enide&#39;, termina con &#39;e&#39;)</span>
<span class="s2">&quot;Enidev911&quot;</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="s2">&quot;ide&quot;</span><span class="p">);</span> <span class="c1">// true (&#39;Enidev911&#39;, incluye &#39;ide&#39;)</span>
<span class="s2">&quot;Enidev911&quot;</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="s2">&quot;Eni&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// false (&#39;ev911&#39;, no incluye &#39;Eni&#39;)</span>
</pre>
    </div>

    <p><a href="#top"><img alt=""
          src="https://img.shields.io/badge/regresar%20a%20contenido%20principal-%E2%86%A9-%232BAAEC?style=for-the-badge&amp;logo=readthedocs&amp;logoColor=%23FAC173" /></a>
    </p>
    <hr />
    <h2 id="busquedas-con-regexp">BÚSQUEDAS CON REGEXP<a class="headerlink" href="#busquedas-con-regexp"
        title="Permanent link">&#9875;</a></h2>
    <p>Por otro lado, los métodos <strong><code>search()</code></strong>, <strong><code>match()</code></strong> y
      <strong><code>matchAll()</code></strong> realizan búsquedas más potente y flexibles utilizando
      <strong>regexp</strong>. La diferencia de cada una es que, mientras el método <code>search()</code> devuelve la
      posición de la primera ocurrencia detectada (o <strong>-1</strong> si no se encuentra), <code>match()</code>
      devuelve un <code>array</code> con las coincidencias detectadas:
    </p>
    <div class="highlight">
      <pre><span class="kr">const</span> <span class="nx">text</span> <span class="o">=</span> <span class="s2">&quot;El bueno, el malo y el feo.&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">regexp</span> <span class="o">=</span> <span class="sr">/.a.o/g</span><span class="p">;</span>

<span class="nx">text</span><span class="p">.</span><span class="nx">search</span><span class="p">(</span><span class="nx">regexp</span><span class="p">);</span> <span class="c1">// 13, porque la primera coincidencia ocurre en la posición 13</span>
<span class="nx">text</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">regexp</span><span class="p">);</span> <span class="c1">// [&#39;malo&#39;], un array con la coincidencia encontrada</span>
</pre>
    </div>

    <p>Por otro lado, el método <strong><code>.mathAll()</code></strong> realiza la misma acción que
      <code>.match()</code> pero devolviendo iteradores y más información como las propiedades <strong>.index</strong>,
      <strong>.input</strong> o <strong>.groups</strong> en cada resultado de la iteración:
    </p>
    <div class="highlight">
      <pre><span class="kr">const</span> <span class="nx">resultado</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">text</span><span class="p">.</span><span class="nx">matchAll</span><span class="p">(</span><span class="nx">regexp</span><span class="p">)];</span> <span class="c1">// [&#39;malo&#39;]</span>

<span class="nx">result</span><span class="p">.</span><span class="nx">length</span> <span class="c1">//1</span>
<span class="nx">result</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">index</span> <span class="c1">// 13</span>
</pre>
    </div>

    <blockquote>
      <p>Las <strong>expresiones regulares</strong> permiten realizar cosas mucho más avanzadas, lo abordares en un tema
        posterior.</p>
    </blockquote>
    <p><a href="#top"><img alt=""
          src="https://img.shields.io/badge/regresar%20a%20contenido%20principal-%E2%86%A9-%232BAAEC?style=for-the-badge&amp;logo=readthedocs&amp;logoColor=%23FAC173" /></a>
    </p>
    <hr />
    <h3 id="metodos-para-transformar"><a name="string-transform-methods"></a> MÉTODOS PARA TRANSFORMAR<a
        class="headerlink" href="#metodos-para-transformar" title="Permanent link">&#9875;</a></h3>
    <p>En javascript podemos utilizar algunos métodos para modificar un <code class="str">string</code> realizando
      alguna operación
      de transformación. En esta tabla tenemos dichos métodos: </p>
    <table>
      <thead>
        <tr>
          <th>Método</th>
          <th>Descripción</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>.repeat(n)</code></td>
          <td>Devuelve el texto de la variable <strong>n</strong> veces.</td>
        </tr>
        <tr>
          <td><code>.toLowerCase()</code></td>
          <td>Devuelve el texto de la variable en minúsculas.</td>
        </tr>
        <tr>
          <td><code>.toUpperCase()</code></td>
          <td>Devuelve el texto de la variable en mayúscula.</td>
        </tr>
        <tr>
          <td><code>.trim()</code></td>
          <td>Devuelve el texto sin espacios a la izquierda y derecha.</td>
        </tr>
        <tr>
          <td><code>.trimStart()</code></td>
          <td>Devuelve el texto sin espacios a la izquierda.</td>
        </tr>
        <tr>
          <td><code>.trimEnd()</code></td>
          <td>Devuelve el texto sin espacios a la derecha.</td>
        </tr>
        <tr>
          <td><code>.replace(str|regex,newstr)</code></td>
          <td>Reemplaza la primera aparición del texto <strong>str</strong> por <strong>newstr</strong>.</td>
        </tr>
        <tr>
          <td><code>.replaceAll(str|regex,newstr)</code></td>
          <td>Remplaza todas las apariciones del texto <strong>str</strong> por <strong>newstr</strong>.</td>
        </tr>
        <tr>
          <td><code>.replace(str|regex,func)</code></td>
          <td>Identico a <code>.replace()</code>, pero reemplazando por la devolución de <strong>func</strong>.</td>
        </tr>
        <tr>
          <td><code>.substr(ini,len)</code></td>
          <td>Devuelve el subtexto desde la posición <strong>ini</strong> hasta
            <strong>ini</strong>+<strong>len</strong>.
          </td>
        </tr>
        <tr>
          <td><code>.substring(ini,end)</code></td>
          <td>Devuelve el subtexto desde la posición <strong>ini</strong> hasta <strong>end</strong>.</td>
        </tr>
        <tr>
          <td><code>.slice(ini,end)</code></td>
          <td>Identico a <code>.substr()</code> con leves diferencias.</td>
        </tr>
        <tr>
          <td><code>.split(sep|regex,limit)</code></td>
          <td>Separa el texto usando <strong>sep</strong> como separador, en <strong>limit</strong> fragmentos.</td>
        </tr>
        <tr>
          <td><code>.padStart(len,str)</code></td>
          <td>Rellena el principio de la cadena con <strong>str</strong> hasta llegar al tamaño <strong>len</strong>
          </td>
        </tr>
        <tr>
          <td><code>.padEnd(len,stre)</code></td>
          <td>Rellena al final de la cadena <strong>str</strong> hasta llegar al tamaño <strong>len</strong>.</td>
        </tr>
      </tbody>
    </table>
    <p>El método <code>.repeat(n)</code> devuevlve como <code class="str">string</code> el texto repetido
      <strong>n</strong> veces.
      Por otro lado, los métodos <code>toLowerCase()</code> y <code>toUpperCase()</code> devuelven el texto convertido
      todo a minúsculas o todo a mayúsculas respectivamente.
    </p>
    <div class="highlight">
      <pre><span class="s2">&quot;Na&quot;</span><span class="p">.</span><span class="nx">repeat</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// &#39;NaNaNaNaNa&#39;</span>
<span class="s2">&quot;EniDev911&quot;</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">();</span> <span class="c1">// enidev911</span>
<span class="s2">&quot;enidev911&quot;</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">();</span> <span class="c1">// ENIDEV911</span>
<span class="s2">&quot;        holaa        &quot;</span><span class="p">.</span><span class="nx">trim</span><span class="p">();</span> <span class="c1">// &#39;hola&#39;</span>
</pre>
    </div>

    <p>Por último el método <code>trim()</code>, informalmente traducido como &lt;<afeitart>&gt; se encarga de devolver
        el texto eliminando los espacios sobrantes que hay a la izquierda y a la derecha del texto (y sólo, esos
        espacios, nunca los que existen entre una plabra y otra). De la misma forma el método <code>trimStart()</code> y
        <code>trimEnd()</code> realizan la misma tarea sólo a la izquierda o sólo a la derecha respectivamente.</p>
    <p><a href="#top"><img alt=""
          src="https://img.shields.io/badge/regresar%20a%20contenido%20principal-%E2%86%A9-%232BAAEC?style=for-the-badge&amp;logo=readthedocs&amp;logoColor=%23FAC173" /></a>
    </p>
    <hr />
    <h3 id="remplazar-textos"><a name="string-replace"></a> REMPLAZAR TEXTOS<a class="headerlink"
        href="#remplazar-textos" title="Permanent link">&#9875;</a></h3>
    <p>Uno de los métodos más interesantes de transformación de <code class="str">string</code> es el
      <code>replace(str,newstr)</code>. Su funcionalidad más básica, como se ve en el primer ejemplo, se trata de
      devolver el texto en cuestión, remplazando el texto <strong>str</strong> por <strong>newstr</strong> (&lsquo;solo
      la primera aparición&rsquo;):
    </p>
    <div class="highlight">
      <pre><span class="s2">&quot;Amigo&quot;</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;Ene&quot;</span><span class="p">);</span> <span class="c1">// &#39;Enemigo&#39;</span>
<span class="s2">&quot;Dispara&quot;</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">);</span> <span class="c1">// &#39;Dispira&#39; (sólo remplaza la primera aparición)</span>
<span class="s2">&quot;Dispara&quot;</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/a/g</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">);</span> <span class="c1">// &#39;Dispiri&#39; (remplaza todas las ocurrencias)</span>
</pre>
    </div>

    <p>Si lo que nos interesa es reemplazar todas las apariciones, tendremos que hacer uso de las <strong>expresiones
        regulares</strong>, que veremos en temas posteriores a este. A grandes rasgos, en el tercer ejemplo anterior, en
      lugar de indicar el <code class="str">string</code> <strong>&lsquo;a&rsquo;</strong> indicamos la expresión
      regular
      <strong>/a/g</strong> que buscará todas las apariciones de <strong>a</strong> de forma global (todas las
      ocurrencias).
    </p>
    <div class="highlight">
      <pre><span class="kr">const</span> <span class="nx">frase</span> <span class="o">=</span> <span class="s2">&quot;JavaScript es un gran lenguaje&quot;</span><span class="p">;</span>
<span class="nx">frase</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[aeiou]/g</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">);</span> <span class="c1">// &#39;Jiviscript is in grin linguiiji&#39;</span>
</pre>
    </div>

    <blockquote>
      <p>Desde Ecmacript {.es2021} es posible utilizar el método <code>replaceAll()</code> para remplazar todas las
        <strong>ocurrencias</strong> de un texto o de una expresión regular. Funciona exactamente igual que
        <code>replace()</code>, sólo que remplaza todas las ocurrencias en vez de solamente la primera.
      </p>
    </blockquote>
    <p>Además, el método <code>replace()</code> nps permite indicar, como segundo parámetro una
      <strong><code>function</code></strong> en lugar de un <code class="str">string</code>, permitiendo utilizar dicha
      función para
      realizar un proceso más complejo al remplazar, en lugar de simplemente remplazar por un <code
        class="str">string</code>. Sin
      embargo, para aprender a utilizar esta funcionalidad, antes tendremos que aprender sobre los
      <strong>callbacks</strong>, que veremos en temas posteriores.
    </p>
    <iframe
      src="https://codesandbox.io/embed/gracious-wiles-vf2vr2?expanddevtools=1&fontsize=14&hidenavigation=1&theme=dark"
      style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" title="gracious-wiles-vf2vr2"
      allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
      sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe>
    <p><a href="#top"><img alt=""
          src="https://img.shields.io/badge/regresar%20a%20contenido%20principal-%E2%86%A9-%232BAAEC?style=for-the-badge&amp;logo=readthedocs&amp;logoColor=%23FAC173" /></a>
    </p>
    <hr />
    <h3 id="extraer-subtextos"><a name="string-extract"></a> EXTRAER SUBTEXTOS<a class="headerlink"
        href="#extraer-subtextos" title="Permanent link">&#9875;</a></h3>
    <p>Otras de las operaciones fundamentales de los <code class="str">string</code>es la posibilidad de extraer
      pequeños
      fragmentosde texto de textos más grandes. Para ello tenemos dos aproximaciones para realizarlo: con el método
      <code>substr()</code> o con el método <code>substring()</code>.
    </p>
    <p>En el primer caso, el método <code>substr(ini,len)</code> nos solicita dos parámetros, <strong>ini</strong>, que
      es la posición inicial del subtexto, y <strong>len</strong>, que es el tamaño o longitud que tendrá el texto. De
      esta forma, <code>substr(2,4)</code> extrae el fragmento de texto desde la posición <strong>2</strong> y desde esa
      posición <strong>4</strong> posiciones más. En el caso de omitirse el parámetro <strong>len</strong>, se devuelve
      el subtexto hasta el final del texto original.</p>
    <div class="highlight">
      <pre><span class="s2">&quot;submarino&quot;</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// &#39;marino&#39; (desde el 3 en adelante)</span>
<span class="s2">&quot;submarino&quot;</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// &#39;m&#39; (desde el 3, hasta el 3+1)</span>
<span class="s2">&quot;submarino&quot;</span><span class="nx">substring</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// &#39;marino&#39; (desde el 3 en adelante)</span>
<span class="s2">&quot;submarino&quot;</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">);</span> <span class="c1">// &#39;mar&#39; (desde el 3 hasta el 6)</span>
</pre>
    </div>

    <p>Por otro lado el método <code>substring(ini,end)</code> extrae el fragmento de texto desde la posición
      <strong>ini</strong> hasta la posición <strong>end</strong>. De igual forma al anterior, si se omite el parámetro
      <strong>end</strong>, el subtexto abarcará hasta el final del texto original.
    </p>
    <p><a href="#top"><img alt=""
          src="https://img.shields.io/badge/regresar%20a%20contenido%20principal-%E2%86%A9-%232BAAEC?style=for-the-badge&amp;logo=readthedocs&amp;logoColor=%23FAC173" /></a>
    </p>
    <hr />
    <h3 id="crear-arrays-a-partir-de-textos"><a name="string-split"></a> CREAR ARRAYS A PARTIR DE TEXTOS<a
        class="headerlink" href="#crear-arrays-a-partir-de-textos" title="Permanent link">&#9875;</a></h3>
    <p>Otro método muy útil es <code>split(sep)</code>, un método que permite <strong>dividir</strong> un
      <code class="str">string</code> por el substring <strong>sep</strong> como separador, devolviendo un array con
      cada una de las
      partes divididas. Es muy útil para <strong>crear arrays</strong>, o dividir en diferentes secciones textos que
      tienen <strong>separadores</strong> repetidos como podrían ser comas, puntos o pipes <code>|</code>.
    </p>
    <div class="highlight">
      <pre><span class="s2">&quot;1.2.3.4.5&quot;</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">);</span> <span class="c1">// [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;] (5 elementos)</span>
<span class="s2">&quot;Hola lenguaje javascript&quot;</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">);</span> <span class="c1">// [&#39;Hola&#39;, &#39;lenguaje&#39;, &#39;javascript&#39;] (3 elementos)</span>
<span class="s2">&quot;Código&quot;</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span> <span class="c1">// [&#39;C&#39;, &#39;ó&#39;, &#39;d&#39;, &#39;i&#39;, &#39;g&#39;, &#39;o&#39;] (6 elementos)</span>
</pre>
    </div>

    <p>En el último ejemplo, el separador es una <strong>cadena vacía</strong>, es decir &lt;<ningún carácter>&gt;, lo
        que hace es hacer una división en su unidad mínima, carácter por carácter.</p>
    <blockquote>
      <p>En el tema de los arrays veremos un método llamado <strong><code>join()</code></strong> que es justo el opuesto
        de <strong><code>split()</code></strong>. Si <strong>split</strong> separa un string en varios y los coloca
        dentro de un array, <strong>join</strong> une varios elementos de un array añadiéndole un separador y lo
        convierte en un string.</p>
    </blockquote>
    <p><a href="#top"><img alt=""
          src="https://img.shields.io/badge/regresar%20a%20contenido%20principal-%E2%86%A9-%232BAAEC?style=for-the-badge&amp;logo=readthedocs&amp;logoColor=%23FAC173" /></a>
    </p>
    <hr />
    <h3 id="rellenar-cadenas"><a name="fill-string"></a> RELLENAR CADENAS<a class="headerlink" href="#rellenar-cadenas"
        title="Permanent link">&#9875;</a></h3>
    <p>Otra transformación interesante con los <code class="str">string</code> es la resultante de utilizar métodos como
      <strong><code>padStar(len,str)</code></strong> o <strong><code>padEnd(len,str)</code></strong>. Ambos métodos
      tomandos dos parámetros: <strong>len</strong> la longitud deseada del <code class="str">string</code> resultante y
      <strong>str</strong> el carácter a utilizar como relleno.
    </p>
    <p>El objetivo de ambas funciones es devolver un nuevo <code class="str">string</code> con la información original
      existente,
      pero ampliando su tamaño a <strong>len</strong> y rellenando el resto con <strong>str</strong>, al principio si se
      usa <code>padStart()</code> o al final si se usa <code>padEnd()</code>: </p>
    <div class="highlight">
      <pre><span class="s2">&quot;5&quot;</span><span class="p">.</span><span class="nx">padStart</span><span class="p">(</span><span class="mi">6</span><span class="p">.</span> <span class="s2">&quot;0&quot;</span><span class="p">);</span> <span class="c1">// &#39;000005&#39;</span>
<span class="s2">&quot;A&quot;</span><span class="p">.</span><span class="nx">padEnd</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">);</span> <span class="c1">// &#39;A....&#39;</span>
</pre>
    </div>

    <blockquote>
      <p>Estos métodos resultan especialmente interesantes para formatear horas, como por ejemplo en el caso que
        queramos que las cifras menores a 10 aparezcanen formato <strong>00</strong> en lugar de <strong>0</strong>.</p>
    </blockquote>
    <p><a href="#top"><img alt=""
          src="https://img.shields.io/badge/regresar%20a%20contenido%20principal-%E2%86%A9-%232BAAEC?style=for-the-badge&amp;logo=readthedocs&amp;logoColor=%23FAC173" /></a>
    </p>
    <hr />
    <h3 id="metodos-unicode"><a name="string-unicode"></a> MÉTODOS UNICODE<a class="headerlink" href="#metodos-unicode"
        title="Permanent link">&#9875;</a></h3>
    <p><strong>unicode</strong> es el nombre por el que se conoce al sistema moderno de codificación de carácteres que
      se usa en informática. A grandes rasgos, cada carácter como podría ser la <strong>A</strong>, la
      <strong>B</strong> o cualquier otro, tiene su representación <strong>Unicode</strong>, que se basa en un código o
      <strong>code point</strong>.
    </p>
    <p>Por ejemplo, el carácter <strong>A</strong> corresponde al código Unicode <strong>U+0041</strong>. Este
      <strong>0041</strong> realmente está en hexadecimal, por lo que <strong>0x0041</strong> en decimal sería igual a
      <strong>65</strong>. Existen muchísimos códigos, ya que cualquier carácter existente, tiene su propio código
      Unicode. En Javascript, tenemos dos métodos interesantes relacionados con este tema:
    </p>
    <table>
      <thead>
        <tr>
          <th>Método</th>
          <th>Descripción</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>String.fromCharCode(num)</code></td>
          <td>Devuelve el carácter del valor <strong>unicode</strong> indicado en <strong>num</strong>.</td>
        </tr>
        <tr>
          <td><code>.charCodeAt(pos)</code></td>
          <td>Devuelve el valor <strong>unicode</strong> del carácter de la posición <strong>pos</strong> del texto.
          </td>
        </tr>
      </tbody>
    </table>
    <p>El primero de ellos es un método estático, por lo que hay que escribir directamente
      <strong>String.fromCharCode()</strong> y no utilizarlo desde una variable. Para usar este método, le pasamos un
      <strong>num</strong> por parámetro, que indicará el número o código Unicode al que queremos hacer referencia, y el
      método nos devolverá un <code class="str">string</code> con el carácter Unicode en cuestión:
    </p>
    <div class="highlight">
      <pre><span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">(</span><span class="mi">65</span><span class="p">);</span> <span class="c1">// &#39;A&#39; (65 es el código U+0041 en decimal)</span>
<span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">(</span><span class="mh">0x0041</span><span class="p">);</span> <span class="c1">// &#39;A&#39; (0x0041) es el código U+0041 en hexadecimal)</span>
<span class="s2">&quot;A&quot;</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 65</span>
<span class="s2">&quot;A&quot;</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span> <span class="c1">// 41</span>
</pre>
    </div>

    <p>Por otro lado, el método <strong>charCodeAt()</strong> es la operación inversa a
      <strong>String.fromCharCode()</strong> con algún extra. A <strong>charCodeAt(pos)</strong> le pasamos una posición
      <strong>pos</strong> por parámetro. Esto buscará el carácter de la posición <strong>pos</strong> del
      <code class="str">string</code> y nos devolverá su código Unicode (por defecto, un decimal). Si queremos pasarlo a
      otra base
      numérica, podemos hacer uso del método <code>toString(base)</code> indicando <strong>16</strong> como
      <strong>base</strong>.
    </p>
    <p>Observa a continuación que, lo tan famosos <strong>emojis</strong> por ejemplo, son realmente una combinación de
      2 códigos Unicode.</p>
    <div class="highlight">
      <pre><span class="c1">// El valor unicode del emoji 🐦 es (55357, 56358)</span>
<span class="nx">emoji</span> <span class="o">=</span> <span class="s2">&quot;🐦&quot;</span><span class="p">;</span>
<span class="nx">codigos</span> <span class="o">=</span> <span class="p">[];</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span> <span class="nx">emoji</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="nx">codigos</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">emoji</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span>
<span class="p">}</span>
<span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">(...</span><span class="nx">codigos</span><span class="p">);</span> <span class="c1">// &#39;🐦&#39; (Usamos desestructuración, veremos en temas posteriores)</span>
</pre>
    </div>

    <p>Observa que modificando el último código Unicode, podemos obtener diferentes <strong>emojis</strong>:</p>
    <div class="highlight">
      <pre><span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">(</span><span class="mi">55357</span><span class="p">,</span> <span class="mi">56358</span><span class="p">);</span> <span class="c1">// &#39;🐦&#39;</span>
<span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">(</span><span class="mi">55357</span><span class="p">,</span> <span class="mi">56359</span><span class="p">);</span> <span class="c1">// &#39;🐧&#39;</span>
<span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">(</span><span class="mi">55357</span><span class="p">,</span> <span class="mi">56360</span><span class="p">);</span> <span class="c1">// &#39;🐨&#39;)</span>
<span class="p">(</span><span class="s2">&quot;\u0041&quot;</span><span class="p">);</span> <span class="c1">// &#39;A&#39;</span>
<span class="p">(</span><span class="s2">&quot;\ud83d\udc28&quot;</span><span class="p">);</span> <span class="c1">// &#39;🐨&#39;</span>
</pre>
    </div>

    <p>Una forma rápida de escribir <strong>carácteres Unicode</strong> es utilizando la secuencia de escape
      <strong>\u</strong> seguida del código Unicode en hexadecimal del caracter en cuestión, como se ve en los últimos
      ejemplos anteriores.
    </p>
    <p><a href="#top"><img alt=""
          src="https://img.shields.io/badge/regresar%20a%20contenido%20principal-%E2%86%A9-%232BAAEC?style=for-the-badge&amp;logo=readthedocs&amp;logoColor=%23FAC173" /></a>
    </p>
    <hr />
    <h3 id="interpolacion-de-variables"><a name="string-backstips"></a> INTERPOLACIÓN DE VARIABLES<a class="headerlink"
        href="#interpolacion-de-variables" title="Permanent link">&#9875;</a></h3>
    <p>En <strong>ECMAScript ES2015</strong> se introducierón una interesante mejora en la manipulación general de
      <code class="str">string</code>, sobre todo respecto a la legibilidad de código.
    </p>
    <p>Hasta ahora, si queríamos concatenar el valor de algunas variables con textos predefinidos por nosotros, teníamos
      que hacer algo parecido a esto: </p>
    <p>
    <div class="highlight">
      <pre><span class="kr">const</span> <span class="nx">sujeto</span> <span class="o">=</span> <span class="s2">&quot;frase&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">adjetivo</span> <span class="o">=</span> <span class="s2">&quot;concatenada&quot;</span><span class="p">;</span>
<span class="s2">&quot;Una &quot;</span> <span class="o">+</span> <span class="nx">sujeto</span> <span class="o">+</span> <span class="s2">&quot; bien &quot;</span> <span class="o">+</span> <span class="nx">adjetivo</span><span class="p">;</span> <span class="c1">// &#39;Una frase bien concatenada&#39;</span>
</pre>
    </div>
    A medida que añadimos más variable, el código se hace bastante menos claro y más complejo de leer, especialmente
    si
    tenemos que añadir arrays, introducir comillas simples que habríamos que escapar con <strong>'</strong> o combinar
    comillas simples con dobles, etc&hellip;</p>
    <p>Para evitarlo, se introducen los <strong>backsticks</strong> (<em>comillas hacia atrás</em>), que nos permiten
      <strong>interpolar</strong> el valor de las variables sin tener que cerrar, concatenar y abrir la cadena de
      texto
      continuamente:<br />
    <div class="highlight">
      <pre><span class="kr">const</span> <span class="nx">sujeto</span> <span class="o">=</span> <span class="s2">&quot;frase&quot;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">adjetivo</span> <span class="o">=</span> <span class="s2">&quot;concatenada&quot;</span><span class="p">;</span>
<span class="s2">`Una</span> <span class="go">$</span><span class="p">{</span><span class="nx">sujeto</span><span class="p">}</span> <span class="s2">mejor</span> <span class="go">$</span><span class="p">{</span><span class="nx">concatenada</span><span class="p">}</span><span class="s2">`</span>
</pre>
    </div>
    </p>
    <p>Esto es una funcionalidad muy simple, pero que mejora sustancialmente la calidad de código generado.</p>
  </article>
</body>

</html>